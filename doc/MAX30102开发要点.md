# MAX30102 开发要点总结

## 1. 传感器特性

| 参数 | 值 | 说明 |
|------|-----|------|
| 采样率 | 100Hz | 每10ms产生一个样本 |
| I2C地址 | 0x57 | 7位地址 |
| FIFO深度 | 32样本 | 数据缓冲 |
| 数据格式 | 18位 | 3字节，高2位为状态 |

## 2. 关键配置

```c
// 初始化配置
max30102_Bus_Write(REG_FIFO_CONFIG, 0x0f);  // sample avg=1, fifo rollover=false
max30102_Bus_Write(REG_SPO2_CONFIG, 0x27);  // 100Hz, 400uS脉冲宽度
max30102_Bus_Write(REG_LED1_PA, 0x24);      // LED1电流 ~7mA
max30102_Bus_Write(REG_LED2_PA, 0x24);      // LED2电流 ~7mA
max30102_Bus_Write(REG_MODE_CONFIG, 0x03);  // SpO2模式
```

## 3. INT引脚功能

- **低电平**：有新数据可读
- **高电平**：等待数据
- **用法**：轮询或外部中断触发读取

## 4. FIFO读取注意事项

### 必须清除中断标志位
```c
max30102_Bus_Read(REG_INTR_STATUS_1);  // 清除FIFO中断
max30102_Bus_Read(REG_INTR_STATUS_2);  // 清除温度中断
```

### 必须更新FIFO_RD_PTR
```c
// 每次读取FIFO后，指针自动递增
// 如果不更新，指针会"追上"WR_PTR，导致无新数据
max30102_Bus_Write(REG_FIFO_RD_PTR, fifo_wr_ptr);
```

### 正确的数据解析（18位）
```c
red = ((temp[0] & 0x03) << 16) | (temp[1] << 8) | temp[2];
ir  = ((temp[3] & 0x03) << 16) | (temp[4] << 8) | temp[5];
```

## 5. 数据处理算法

### 需要样本数量：500个
- 100Hz采样率 × 5秒 = 500样本
- 算法要求足够的样本才能准确计算

### 滤波处理
- **低通滤波**：平滑信号，`ALPHA = 0.05`
- **滑动平均**：20个样本窗口

### 心率补偿
```c
max30102_data.heart_rate += HEART_RATE_COMPENSATION;  // 补偿值10
```

## 6. 阻塞 vs 非阻塞方案

### 阻塞方案
- **优点**：数据完全连续，计算准确
- **缺点**：阻塞5秒，其他任务无法执行
- **适用场景**：单任务系统

```c
void max30102_task(void)
{
    dis_hr = dis_spo2 = 0;
    while (dis_hr == 0 && dis_spo2 == 0)  // 阻塞5秒
    {
        MAX30102_Read_Data();      // 读500个样本
        Calculate_Heart_Rate_and_SpO2();
        Update_Signal_Min_Max();
        Process_And_Display_Data();
    }
}
```

### 非阻塞方案
- **优点**：不阻塞其他任务
- **缺点**：样本时间上不够连续，稳定性略差
- **适用场景**：多任务系统

```c
void max30102_task(void)
{
    switch (g_measuring)
    {
        case 0:  // 开始测量
            g_sample_idx = 0;
            g_measuring = 1;
            break;

        case 1:  // 采集中（每次50个样本）
            for (int i = 0; i < 50; i++)
            {
                if (g_sample_idx >= 500) break;
                read_single_sample();
                g_sample_idx++;
                delay_us(500);
            }
            if (g_sample_idx >= 500)
            {
                Calculate_Heart_Rate_and_SpO2();
                g_measuring = 2;
            }
            break;

        case 2:  // 完成
            Process_And_Display_Data(1);
            g_measuring = 0;
            break;
    }
}
```

## 7. 超时保护

传感器无响应时，防止程序永久阻塞：

```c
uint32_t timeout = 100000;
while (MAX30102_INT == 1) {
    if (--timeout == 0) {
        my_printf("timeout\r\n");
        return;  // 等下次任务再试
    }
}
```

## 8. 常见问题与解决方案

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 读不到数据 | INT引脚未上拉 | 配置GPIO上拉输入 |
| 数值全0 | FIFO_RD_PTR未更新 | 每次读取后更新指针 |
| 数据不变 | 连续读取太快 | 加delay_us(500)延时 |
| 心率值偏大 | 算法偏差 | 加心率补偿+10 |
| 稳定性差 | 采集时间太长 | 减少到2秒（50样本×10次） |
| 串口停打印 | 阻塞导致看门狗复位 | 加超时保护 |

## 9. 性能对比

| 方案 | 采集时间 | 其他任务 | 稳定性 |
|------|----------|----------|--------|
| 阻塞（25样本/次） | 4秒 | 被阻塞 | 较好 |
| 阻塞（50样本/次） | 2秒 | 被阻塞 | 较好 |
| 非阻塞（25样本/次） | 4秒 | 正常运行 | 一般 |
| 非阻塞（50样本/次） | 2秒 | 正常运行 | 一般 |

## 10. 推荐配置

```c
// 调度器配置
#define MAX30102_RATE_MS    200   // 任务周期
#define SAMPLES_PER_CALL    50    // 每次读取样本数
#define TOTAL_SAMPLES       500   // 总样本数
#define SAMPLE_DELAY_US     500   // 样本间延时

// 任务执行时间估算
// 50样本 × 500us = 25ms/次（远小于200ms周期）
```
